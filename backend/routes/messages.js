const express = require('express');
const EmployeeMessage = require('../models/EmployeeMessage');
const Employee = require('../models/Employee');
const WeatherAbsence = require('../models/WeatherAbsence');
const WorkReport = require('../models/WorkReport');
const { auth, isAdmin } = require('../middleware/auth');
const { getWeatherData } = require('../services/weatherService');
const router = express.Router();

/**
 * Message Center Routes
 * 
 * Uses the same MongoDB Atlas connection as all other modules (Employee, Company, etc.)
 * Connection is established in server.js via mongoose.connect(process.env.MONGO_URI)
 * All models automatically use this shared connection.
 * 
 * Messages are stored in the 'employeemessages' collection in the same database.
 * Each message links to employees via employeeId (Employee._id.toString())
 */

// Get messages for current employee
router.get('/me', auth, async (req, res) => {
  try {
    const { category, unreadOnly } = req.query;
    const userId = req.user._id.toString();
    
    console.log(`üì¨ Fetching messages for Employee ID: ${userId}`);
    
    // Find employee by userId - employees are stored in employees collection
    const employee = await Employee.findOne({ _id: userId });
    
    if (!employee) {
      console.log(`‚ö†Ô∏è  Employee not found for userId: ${userId}`);
      return res.json([]); // Return empty array if employee not found
    }
    
    const employeeId = employee._id.toString();
    console.log(`‚úÖ Found employee: ${employee.name} (${employeeId})`);
    
    let query = { employeeId: employeeId };
    
    if (category && category !== 'all') {
      query.category = category;
    }
    
    if (unreadOnly === 'true') {
      query.readStatus = false;
    }
    
    const messages = await EmployeeMessage.find(query)
      .sort({ timestamp: -1, createdAt: -1 })
      .limit(100);
    
    console.log(`‚úÖ Fetched ${messages.length} messages for Employee ${employeeId}`);
    res.json(messages);
  } catch (error) {
    console.error('‚ùå Get messages error:', error);
    res.status(500).json({ error: 'Failed to get messages' });
  }
});

// Get all messages (admin only)
router.get('/', auth, isAdmin, async (req, res) => {
  try {
    const { employeeId, category, unreadOnly } = req.query;
    console.log(`üìã Admin fetching all messages`, { employeeId, category, unreadOnly });
    
    let query = {};
    
    if (employeeId) {
      // Convert to string to ensure proper matching
      const employee = await Employee.findById(employeeId);
      if (employee) {
        query.employeeId = employee._id.toString();
        console.log(`‚úÖ Filtering by employee: ${employee.name} (${query.employeeId})`);
      } else {
        console.log(`‚ö†Ô∏è  Employee not found: ${employeeId}`);
      }
    }
    
    if (category && category !== 'all') {
      query.category = category;
    }
    
    if (unreadOnly === 'true') {
      query.readStatus = false;
    }
    
    const messages = await EmployeeMessage.find(query)
      .sort({ timestamp: -1, createdAt: -1 })
      .limit(500);
    
    console.log(`‚úÖ Fetched ${messages.length} messages for admin`);
    res.json(messages);
  } catch (error) {
    console.error('‚ùå Get all messages error:', error);
    res.status(500).json({ error: 'Failed to get messages' });
  }
});

// Create message (admin only)
router.post('/', auth, isAdmin, async (req, res) => {
  try {
    const { employeeId, category, title, message, important } = req.body;
    
    console.log(`üì§ Creating message for Employee ID: ${employeeId}`);
    console.log(`üìù Message details:`, { category, title, important });
    
    if (!employeeId || !category || !title || !message) {
      console.log('‚ùå Missing required fields');
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    // Find employee by ID to verify they exist
    const employee = await Employee.findById(employeeId);
    
    if (!employee) {
      console.log(`‚ùå Employee not found: ${employeeId}`);
      return res.status(404).json({ error: 'Employee not found' });
    }
    
    console.log(`‚úÖ Found employee: ${employee.name} (${employee._id})`);
    
    // Get sender name from authenticated admin
    const Company = require('../models/Company');
    const admin = await Company.findById(req.user._id);
    const sender = admin ? admin.name : 'Company Admin';
    
    const employeeMessage = new EmployeeMessage({
      employeeId: employee._id.toString(),
      employeeUserId: employee._id,
      sender: sender,
      category,
      title,
      message,
      messageText: message, // Ensure messageText is set
      important: important || false,
      autoGenerated: false,
      timestamp: new Date()
    });
    
    await employeeMessage.save();
    console.log(`‚úÖ Message saved successfully with ID: ${employeeMessage._id}`);
    console.log(`üì¨ Message sent to Employee ${employeeId} by ${sender}`);
    
    res.status(201).json({ 
      message: 'Message sent successfully', 
      data: employeeMessage 
    });
  } catch (error) {
    console.error('‚ùå Create message error:', error);
    console.error('Error details:', error.message);
    res.status(500).json({ error: 'Failed to create message: ' + error.message });
  }
});

// Mark message as read
router.put('/:id/read', auth, async (req, res) => {
  try {
    const messageId = req.params.id;
    console.log(`üìñ Marking message as read: ${messageId}`);
    
    const message = await EmployeeMessage.findById(messageId);
    
    if (!message) {
      console.log(`‚ùå Message not found: ${messageId}`);
      return res.status(404).json({ error: 'Message not found' });
    }
    
    // Find employee by userId
    const employee = await Employee.findById(req.user._id);
    
    if (!employee) {
      console.log(`‚ùå Employee not found: ${req.user._id}`);
      return res.status(403).json({ error: 'Access denied' });
    }
    
    const employeeId = employee._id.toString();
    
    // Verify message belongs to current user
    if (message.employeeId !== employeeId) {
      console.log(`‚ùå Access denied: Message employeeId (${message.employeeId}) != current employee (${employeeId})`);
      return res.status(403).json({ error: 'Access denied' });
    }
    
    message.readStatus = true;
    message.readAt = new Date();
    await message.save();
    
    console.log(`‚úÖ Message ${messageId} marked as read by Employee ${employeeId}`);
    res.json({ message: 'Message marked as read', data: message });
  } catch (error) {
    console.error('‚ùå Mark read error:', error);
    res.status(500).json({ error: 'Failed to mark message as read' });
  }
});

// Delete message (admin only)
router.delete('/:id', auth, isAdmin, async (req, res) => {
  try {
    const messageId = req.params.id;
    console.log(`üóëÔ∏è  Deleting message: ${messageId}`);
    
    const message = await EmployeeMessage.findByIdAndDelete(messageId);
    
    if (!message) {
      console.log(`‚ùå Message not found: ${messageId}`);
      return res.status(404).json({ error: 'Message not found' });
    }
    
    console.log(`‚úÖ Message ${messageId} deleted successfully`);
    res.json({ message: 'Message deleted successfully' });
  } catch (error) {
    console.error('‚ùå Delete message error:', error);
    res.status(500).json({ error: 'Failed to delete message' });
  }
});

// Search employees
router.post('/search-employees', auth, isAdmin, async (req, res) => {
  try {
    const { query } = req.body;
    
    if (!query || query.length < 2) {
      return res.json([]);
    }
    
    const employees = await Employee.find({
      $or: [
        { name: { $regex: query, $options: 'i' } },
        { email: { $regex: query, $options: 'i' } },
        { _id: { $regex: query, $options: 'i' } }
      ]
    }).select('_id name email avatar').limit(20);
    
    res.json(employees);
  } catch (error) {
    console.error('Search employees error:', error);
    res.status(500).json({ error: 'Failed to search employees' });
  }
});

// Generate automated alerts
router.post('/generate-alerts', auth, isAdmin, async (req, res) => {
  try {
    const alerts = [];
    
    // Attendance alerts - find employees with 2+ consecutive unapproved absences
    const absenceRequests = await WeatherAbsence.find({ status: 'pending' });
    const absenceCounts = {};
    
    absenceRequests.forEach(req => {
      if (!absenceCounts[req.employeeId]) {
        absenceCounts[req.employeeId] = [];
      }
      absenceCounts[req.employeeId].push(req);
    });
    
    for (const [employeeId, requests] of Object.entries(absenceCounts)) {
      if (requests.length >= 2) {
        // Try to find employee by _id first, then by employeeId string
        let employee = await Employee.findById(employeeId);
        if (!employee) {
          // If not found by _id, search by employeeId field in WeatherAbsence
          employee = await Employee.findOne({ _id: requests[0].userId });
        }
        if (employee) {
          const alertMessage = `You've missed ${requests.length} consecutive days. Please update your attendance status.`;
          const alert = new EmployeeMessage({
            employeeId: employee._id.toString(),
            employeeUserId: employee._id,
            sender: 'Automated System',
            category: 'attendance',
            title: 'Attendance Alert',
            message: alertMessage,
            messageText: alertMessage,
            autoGenerated: true,
            important: true,
            timestamp: new Date()
          });
          await alert.save();
          console.log(`‚úÖ Generated attendance alert for Employee ${employee._id}`);
          alerts.push(alert);
        }
      }
    }
    
    // Weather alerts - check upcoming severe weather for employees
    const recentAbsences = await WeatherAbsence.find({})
      .sort({ submittedAt: -1 })
      .limit(100);
    
    const employeeLocations = {};
    recentAbsences.forEach(abs => {
      if (!employeeLocations[abs.employeeId]) {
        employeeLocations[abs.employeeId] = abs.location;
      }
    });
    
    for (const [employeeId, location] of Object.entries(employeeLocations)) {
      try {
        const weather = await getWeatherData(location);
        if (weather.condition === 'stormy' || weather.condition === 'rainy') {
          // Find employee - employeeId might be string from WeatherAbsence or ObjectId
          let employee = await Employee.findById(employeeId);
          if (!employee) {
            // Try finding by userId from the absence record
            const absence = await WeatherAbsence.findOne({ employeeId });
            if (absence && absence.userId) {
              employee = await Employee.findById(absence.userId);
            }
          }
          if (employee) {
            const alertMessage = `‚ö†Ô∏è ${weather.condition === 'stormy' ? 'Severe weather' : 'Heavy rain'} expected tomorrow in ${location}. Plan your commute accordingly.`;
            const alert = new EmployeeMessage({
              employeeId: employee._id.toString(),
              employeeUserId: employee._id,
              sender: 'Automated System',
              category: 'weather',
              title: 'Weather Alert',
              message: alertMessage,
              messageText: alertMessage,
              autoGenerated: true,
              important: true,
              metadata: { location, weather },
              timestamp: new Date()
            });
            await alert.save();
            console.log(`‚úÖ Generated weather alert for Employee ${employee._id} in ${location}`);
            alerts.push(alert);
          }
        }
      } catch (err) {
        console.error(`Failed to get weather for ${location}:`, err.message);
      }
    }
    
    res.json({ message: `Generated ${alerts.length} alerts`, alerts });
  } catch (error) {
    console.error('Generate alerts error:', error);
    res.status(500).json({ error: 'Failed to generate alerts' });
  }
});

module.exports = router;
